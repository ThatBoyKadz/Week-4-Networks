Section 1:

1Ô∏è‚É£ Why do security systems rely on file hashes instead of timestamps or file sizes?

Timestamps and file sizes are easy to fake or manipulate.

Example: malware could copy a file of the same size or reset the timestamp to make it appear unchanged.

Hashes (like SHA-256) produce a unique fingerprint of the file content.

Even a single bit change in the file will produce a completely different hash.

Hashes are deterministic and hard to forge: it‚Äôs practically impossible to create a malicious file that has the same SHA-256 hash as a legitimate file.

‚úÖ Summary: Hashes provide strong integrity verification, while timestamps and sizes are weak indicators.

2Ô∏è‚É£ How might malware attempt to evade integrity checking?

Malware often tries to bypass or trick hash-based checks:

In-place modification:

It could modify files in memory instead of on disk, so the stored file hash doesn‚Äôt change.

Hash collisions (theoretical, very rare with SHA-256):

Some advanced attacks try to create two different files with the same hash.

Practically infeasible with modern hashes like SHA-256.

Tampering with the integrity checking system itself:

For example, malware could modify the software that calculates and stores hashes.

If the hash database is compromised, integrity checks become useless.

Replacing files with ‚Äúclean‚Äù versions temporarily:

Some malware activates only under certain conditions, leaving files untouched during integrity scans.

‚úÖ Summary: Malware may attack either the files or the checking system, but cryptographic hashes are still much harder to evade than simple size/timestamp checks.

3Ô∏è‚É£ What happens if a legitimate system update changes many hashes ‚Äî and how should you manage that?

Problem: Updates (like Windows patches or application upgrades) change file contents, so hashes of many files will differ from the previously stored hashes.

Na√Øve integrity checks would then report false positives, flagging legitimate updates as ‚Äútampering.‚Äù

How to manage this:

Maintain an updated ‚Äútrusted hash database‚Äù:

Whenever a legitimate update occurs, record the new hashes in a secure database.

Use signed manifests:

Some systems (like OS updates) include signed manifests listing updated files and their new hashes.

Integrity checkers can trust signed updates without manual hash recalculation.

Separate system files from user files:

Only critical system files are monitored.

User files (documents, downloads) can be monitored differently to reduce false positives.

Incremental checks:

Instead of checking everything every time, check only files that are known to be critical or recently changed.

‚úÖ Summary: Manage hash-based integrity checks by updating trusted hashes after legitimate changes and using secure update mechanisms.

-------------------------------------------------------------------------


section 2


How could this approach complement antivirus scanning?

AV software mostly detects known malware patterns (signatures) or suspicious behavior.

Hash-based file integrity monitoring adds another layer: it detects any unexpected file changes, even if the malware is unknown or zero-day.

Example:

AV may not detect a newly written ransomware executable if it‚Äôs not in the signature database.

Your hash monitor will notice that a critical system file was modified or deleted, flagging potential compromise.

‚úÖ Complementary roles:

Tool	Strength	Weakness
Antivirus	Signature/heuristic-based detection	May miss unknown malware
Hash monitoring	Detects any unauthorized file change	Doesn‚Äôt identify malware type
2Ô∏è‚É£ Limitations if a rootkit hides file access at the kernel level

Rootkits can operate at the kernel level, intercepting system calls.

They can hide files, processes, or modifications from the operating system.

Implication for hash-based monitoring:

Your script may not see the malicious file at all.

Hashes may appear unchanged because the rootkit serves fake data to the OS.

This is a fundamental limitation: any OS-level monitoring can be bypassed by kernel-level malware.

Mitigation strategies:

Run integrity checks from a trusted environment (like a live USB or recovery OS).

Combine with behavioral monitoring and memory analysis to detect rootkits.

3Ô∏è‚É£ How to extend this system to automatically restore modified files from backup

You can make a self-healing system using these steps:

Maintain a backup folder containing trusted copies of all monitored files:

myfiles_project/
‚îú‚îÄ myfiles/           ‚Üê active files
‚îú‚îÄ backup/            ‚Üê trusted copies of files


Modify detect_changes.py to replace modified or deleted files with the backup version:

import shutil

backup_folder = "backup"

# Restore modified or deleted files
for filename in modified + deleted:
    src = os.path.join(backup_folder, filename)
    dst = os.path.join(folder, filename)
    if os.path.exists(src):
        shutil.copy2(src, dst)  # copy with metadata
        print(f"Restored: {filename}")


Optional: log changes, so you know what was modified and restored.

Benefits:

Any unauthorized modification can be automatically corrected.

Useful for critical system files, configuration files, or servers.

Considerations:

Ensure backups themselves are protected from malware.

Be careful if legitimate updates occur ‚Äî your system should update backups after trusted changes to avoid restoring outdated files.



---------------------------------------------------------------------

Section 3: 
ignature-based detection works by looking for specific byte patterns or code snippets in a file.

Polymorphic viruses:

Change their code every time they propagate, often by encrypting themselves differently.

The core functionality stays the same, but the byte pattern/signature changes.

Metamorphic viruses:

Completely re-write their own code each time they infect a new host.

Can rearrange instructions, rename variables, or insert no-op code.

Implication:

A static signature cannot reliably match these viruses because the exact sequence of bytes never stays the same.

Signature scanners will miss these threats, making them ineffective against modern, adaptive malware.

2Ô∏è‚É£ Could attackers intentionally include harmless ‚Äúsignature-looking‚Äù strings to trigger false alarms?

Yes ‚Äî this is a known technique called ‚Äúsignature poisoning‚Äù or false positive attack:

Attackers insert strings in benign files that match common antivirus signatures.

Example:

Signature: eval(

Attacker adds a comment in a file: # eval(

Some naive scanners may flag the file as malicious.

Consequences:

Users or administrators may waste time investigating harmless files.

Could be used as a denial-of-service tactic against security teams.

3Ô∏è‚É£ How do heuristic and behavioral scanners improve on this approach?
üîπ Heuristic Scanners

Look for suspicious patterns in code logic, not just exact bytes.

Example rules:

A script that tries to write to the system directory.

A file that modifies executables or injects code into other programs.

Can detect new or unknown malware by identifying risky behaviors.

üîπ Behavioral Scanners

Monitor programs while they run to see what they actually do.

Examples:

Attempts to delete or encrypt many user files.

Network activity connecting to suspicious servers.

Keylogging or memory injection.

Detects malware even if the code is obfuscated or polymorphic.

Key Difference:

Signature scanners = look at static code.

Heuristic/behavioral scanners = look at intent and actions.

---------------------------------------------------------------------------------------

Section 4:
How does the infection curve change if you double the number of attempts per host?

If each infected host scans and attempts to infect twice as many targets, the infection curve becomes:

Steeper (faster exponential rise) ‚Äî because every infected machine causes more secondary infections per unit time.

Shorter time to peak infection ‚Äî the worm saturates the network more quickly.

Higher initial acceleration ‚Äî the first few infected nodes quickly explode into thousands.

In epidemiological terms, it increases the worm‚Äôs effective reproduction number (R).

If your simulation graph was a curve that gradually rises, doubling attempts would turn it into one that ‚Äúshoots up‚Äù almost vertically.

2. Why might a worm choose a local subnet propagation strategy?

Worms often prioritize scanning local subnets (e.g., /24, /16) because:

Advantages

Higher infection probability ‚Äì machines in the same network are more likely to share:

the same vulnerability,

similar system configuration,

lack of patching,

weak passwords.

Low latency & no firewall barriers ‚Äì local traffic often bypasses firewall rules, VLAN restrictions, or NAT boundaries.

Far faster spread ‚Äì scanning local IP ranges is much quicker than scanning random global addresses.

Less noisy ‚Äì scanning the whole internet is detectable; scanning local hosts blends into normal LAN traffic.

Real-world examples:

WannaCry, SQL Slammer, and Conficker all heavily used local subnet scanning.

3. Which containment strategy would be most effective (rate halting, scan detection, thresholding)?
1. Rate Halting (Rate Limiting)

üî• Most effective for fast-spreading worms
If a worm doubles its scanning attempts, rate limiting immediately slows it down.
It reduces the worm‚Äôs ability to propagate exponentially.

Limits the number of outbound connection attempts per second.

Reduces the worm‚Äôs R-value below 1, stopping exponential growth.

üëç Best choice for high-speed worms like Code Red, Slammer.
Scan Detection (Anomaly Detection)

‚úî Effective but slower
If a host starts scanning sequential IP ranges at high speed, the system flags it.

Detects suspicious patterns (like scanning unused ports).

Good for identifying infected devices but usually detects after infection began.

Useful, but not as fast as rate limiting.

3. Thresholding (Connection/Traffic Thresholds)

‚úî Good for containment once detection occurs
The system blocks a host once it exceeds a threshold (like 100 failed scans in 10 seconds).

Works well for preventing reinfection or further spread.

But thresholds may be reached only after the worm already infected others.

Overall Best Strategy

Rate-halting (rate limiting) is the single most effective mechanism for stopping fast‚Äëscanning worms
‚Äî because it attacks the core factor driving exponential propagation: the number of attempts per host.

Combine for best defense:

Rate limit outbound scans

Detect scanning patterns for early alerts

Threshold/block infected hosts immediately

Real systems (Cisco, Palo Alto, Windows Defender ATP) use all three simultaneously.
---------------------------------------------------------------------

